// prisma/schema.prisma
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

/**
 * ======================== MENÚ ========================
 */
model MenuPizza {
  id            Int      @id @default(autoincrement())
  name          String
  category      String?
  selectSize    Json
  priceBySize   Json
  ingredients   Json
  cookingMethod String?
  image         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  stocks StorePizzaStock[]
}

/**
 * ====================== INVENTARIO =====================
 */
model Ingredient {
  id        Int      @id @default(autoincrement())
  name      String
  category  String
  stock     Int      @default(0)
  unit      String?
  costPrice Float?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/**
 * ======================== TIENDA =======================
 */
model Store {
  id              Int               @id @default(autoincrement())
  storeName       String
  address         String
  latitude        Float?
  longitude       Float?
  city            String?
  zipCode         String?
  email           String?
  tlf             String?
  active          Boolean           @default(true)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  acceptingOrders Boolean           @default(true)
  stocks          StorePizzaStock[]
  sales           Sale[]
}

/**
 * junction table: stock por tienda + pizza
 */
model StorePizzaStock {
  storeId   Int
  pizzaId   Int
  stock     Int       @default(0)
  updatedAt DateTime  @updatedAt
  createdAt DateTime  @default(now())
  store     Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)
  pizza     MenuPizza @relation(fields: [pizzaId], references: [id], onDelete: Cascade)

  @@id([storeId, pizzaId])
}

/**
 * ======================== CLIENTE ======================
 */
enum CustomerOrigin {
  PHONE
  WALKIN
  UBER
  GLOVO
  QR
}

// ── nuevo enum
enum CustomerSegment {
  S1 // Potencial: 0–1 compras
  S2 // Inactivo: >1 compras y última > 30 días
  S3 // Activo:   última ≤ 30 días
  S4 // CMV:      S3 y ticket medio > ticket medio empresa
}

model Customer {
  id                Int             @id @default(autoincrement())
  code              String          @unique
  name              String?
  phone             String?         @unique
  email             String?         @unique
  address_1         String          @unique
  portal            String?
  observations      String?
  lat               Float?
  lng               Float?
  origin            CustomerOrigin  @default(PHONE)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  daysOff           Int?
  isRestricted      Boolean         @default(false)
  restrictedAt      DateTime?
  restrictionReason String?
  segment           CustomerSegment @default(S1)
  segmentUpdatedAt  DateTime?

  // ← relación inversa necesaria
  assignedCoupons Coupon[] @relation("CustomerAssignedCoupons")

  sales Sale[] @relation("CustomerSales")
}

/**
 * ========================= VENTA =======================
 */
enum DeliveryMethod {
  PICKUP
  COURIER
  UBER
  GLOVO
}

enum OrderStatus {
  PENDING
  AWAITING_PAYMENT
  PAID
  CANCELED
}

enum Channel {
  WHATSAPP
  PHONE
  WEB
}

// Enums
enum CouponKind {
  PERCENT 
  AMOUNT 
}

enum CouponVariant {
  FIXED 
  RANGE 
}

enum CouponStatus {
  ACTIVE
  USED
  EXPIRED
  DISABLED
}

// Tabla principal
model Coupon {
  id   Int    @id @default(autoincrement())
  code String @unique

  // tipo y variante
  kind    CouponKind    @default(PERCENT)
  variant CouponVariant @default(FIXED)

  // valores según el tipo/variante
  percent    Int? // FIXED + PERCENT
  amount     Decimal? @db.Decimal(10, 2) // FIXED + AMOUNT
  percentMin Int? // RANDOM -> mínimo
  percentMax Int? // RANDOM -> máximo
  maxAmount  Decimal? @db.Decimal(10, 2) // tope de descuento si aplica

  // targeting
  segments     Json? // ["S1","S2",...]
  assignedToId Int? // para Customized
  assignedTo   Customer? @relation("CustomerAssignedCoupons", fields: [assignedToId], references: [id], onDelete: SetNull)

  // ventana de validez
  activeFrom  DateTime?
  expiresAt   DateTime?
  daysActive  Json? // ["lunes","martes",...]
  windowStart Int? // HHmm, ej. 1100
  windowEnd   Int? // HHmm, ej. 2330

  // uso
  usageLimit Int          @default(1) // nº de usos permitidos
  usedCount  Int          @default(0)
  status     CouponStatus @default(ACTIVE)

  // auditoría
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([status])
  @@index([assignedToId])
  @@index([expiresAt])
}

model AppMeta {
  id              Int      @id @default(1)
  acceptingOrders Boolean  @default(true)
  closedMessage   String?  @db.Text
  updatedAt       DateTime @updatedAt
}

model Sale {
  id                      Int            @id @default(autoincrement())
  code                    String         @unique
  date                    DateTime       @default(now())
  deliveredAt             DateTime?
  storeId                 Int
  customerId              Int?
  type                    String
  delivery                DeliveryMethod
  customerData            Json?
  products                Json
  extras                  Json           @default("[]")
  totalProducts           Float
  discounts               Float          @default(0)
  total                   Float
  processed               Boolean        @default(false)
  notes                   String?
  createdAt               DateTime       @default(now())
  status                  OrderStatus    @default(PENDING)
  channel                 Channel        @default(WHATSAPP)
  currency                String         @default("EUR")
  address_1               String?
  lat                     Float?
  lng                     Float?
  stripePaymentIntentId   String?        @unique @db.VarChar(191)
  stripeCheckoutSessionId String?        @unique @db.VarChar(191)

  store    Store     @relation(fields: [storeId], references: [id])
  customer Customer? @relation("CustomerSales", fields: [customerId], references: [id])

  @@index([date])
}
